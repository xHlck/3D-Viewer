<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>VTC 800 - Industrial Viewer</title>
    <style>
        body { margin: 0; background: radial-gradient(circle, #2a2a2a, #000); overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 1.2rem; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

    <div id="loading">CARREGANDO SISTEMA...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- CENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // --- ILUMINA√á√ÉO ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- SISTEMA DE ALARME AVAN√áADO (HALO + LUZ) ---
        
        // 1. Fun√ß√£o para criar textura de brilho via c√≥digo (sem imagem externa)
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 0, 0, 1)'); // Centro vermelho forte
            gradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)'); // Borda transparente
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // 2. O Sprite (A bola de luz brilhante)
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: createGlowTexture(), 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0,
            blending: THREE.AdditiveBlending // Faz a luz "somar" com o fundo (brilho intenso)
        });
        const alarmSprite = new THREE.Sprite(spriteMaterial);
        alarmSprite.scale.set(1.5, 1.5, 1.5); // Tamanho do brilho
        alarmSprite.position.set(0, 3.2, 0); // POSI√á√ÉO DA LUZ (AJUSTE AQUI)
        scene.add(alarmSprite);

        // 3. A Luz Real (Ilumina o metal da m√°quina)
        const alarmRealLight = new THREE.PointLight(0xff0000, 0, 6);
        alarmRealLight.position.copy(alarmSprite.position);
        scene.add(alarmRealLight);


        // --- CONTROLES ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // --- ESTADO ---
        const settings = {
            rotacao: false,
            flutuar: false,
            vistaExplodida: 0,
            xray: false, // Nova funcionalidade
            wireframe: false,
            luzAlarme: false,
            autoZoom: false,
            velocidade: 1.0,
            reset: () => {
                controls.reset();
                settings.rotacao = false;
                settings.xray = false;
                toggleXRay(false);
                gui.controllers.forEach(c => c.updateDisplay());
            }
        };

        // --- GUI ---
        const gui = new GUI({ title: 'Painel VTC 800' });
        
        const f1 = gui.addFolder('Movimento');
        f1.add(settings, 'rotacao').name('Rota√ß√£o Auto');
        f1.add(settings, 'flutuar').name('Flutua√ß√£o');
        f1.add(settings, 'vistaExplodida', 0, 4).name('Explos√£o (Slider)');

        const f2 = gui.addFolder('Diagn√≥stico Visual');
        f2.add(settings, 'xray').name('Modo Raio-X').onChange(toggleXRay);
        f2.add(settings, 'wireframe').name('Modo Aramado').onChange(toggleWireframe);
        f2.add(settings, 'luzAlarme').name('üö® ALARME GERAL').onChange(toggleAlarm);
        
        const f3 = gui.addFolder('C√¢mera');
        f3.add(settings, 'autoZoom').name('Focar Painel').onChange(toggleZoom);
        f3.add(settings, 'reset').name('Resetar Tudo');

        // --- CARREGAMENTO ---
        let model = null;
        let originalPositions = new Map();
        let originalMaterials = new Map(); // Para salvar texturas antes do Raio-X
        let explosionCenter = new THREE.Vector3();

        const loader = new GLTFLoader();
		const driveID = '1zEofyJeRQNiTG1C_Ycw_Ws2mQWv_90Ll';
		const url = `https://docs.google.com/uc?export=download&id=${driveID}`;
 
        //loader.load('asset.data', (gltf) => { // SEU ARQUIVO AQUI
		loader.load(url, function (gltf) {
            model = gltf.scene;
            
            // Centralizar
            const box = new THREE.Box3().setFromObject(model);
            box.getCenter(explosionCenter);
            model.position.sub(explosionCenter.clone());

            scene.add(model);
            document.getElementById('loading').style.display = 'none';

            // Preparar materiais e posi√ß√µes
            model.traverse(child => {
                if (child.isMesh) {
                    originalPositions.set(child.uuid, child.position.clone());
                    
                    // Clonar material para poder modificar (Raio-X) sem perder o original
                    if (child.material) {
                        originalMaterials.set(child.uuid, child.material.clone());
                    }
                }
            });

        }, undefined, (e) => console.error(e));

        // --- L√ìGICA DAS FUN√á√ïES ---

        function toggleWireframe(value) {
            if (!model) return;
            model.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.wireframe = value;
                }
            });
        }

        // Novo: Modo Raio-X
        function toggleXRay(value) {
            if (!model) return;
            model.traverse(child => {
                if (child.isMesh && child.material) {
                    if (value) {
                        // Ativa transpar√™ncia
                        child.material.transparent = true;
                        child.material.opacity = 0.3;
                        child.material.depthWrite = false; // Ajuda a ver "dentro"
                    } else {
                        // Restaura original
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                        child.material.depthWrite = true;
                    }
                }
            });
        }

        let alarmInterval = null;
        function toggleAlarm(value) {
            if (value) {
                let active = false;
                alarmInterval = setInterval(() => {
                    active = !active;
                    // Pisca mudando opacidade do Sprite e Intensidade da luz
                    alarmSprite.material.opacity = active ? 1 : 0.2;
                    alarmSprite.scale.setScalar(active ? 1.8 : 1.4); // Pulsa tamanho
                    alarmRealLight.intensity = active ? 8 : 0;
                }, 300); // R√°pido (300ms)
            } else {
                clearInterval(alarmInterval);
                alarmSprite.material.opacity = 0;
                alarmRealLight.intensity = 0;
            }
        }

        function toggleZoom(value) {
            if (value) {
                // Ajuste aqui a posi√ß√£o do zoom para sua m√°quina
                const target = new THREE.Vector3(1, 0.5, 0); 
                const camPos = new THREE.Vector3(2, 1, 2);
                
                controls.target.copy(target);
                camera.position.copy(camPos);
                controls.autoRotate = false;
            } else {
                controls.reset();
            }
        }

        // --- LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            if (model) {
                // Rota√ß√£o
                if (settings.rotacao) model.rotation.y += delta * 0.5;

                // Flutuar
                if (settings.flutuar) model.position.y = Math.sin(elapsed * 1.5) * 0.1;
                else model.position.y = THREE.MathUtils.lerp(model.position.y, 0, 0.1);

                // Explos√£o
                model.traverse(child => {
                    if (child.isMesh && originalPositions.has(child.uuid)) {
                        const original = originalPositions.get(child.uuid);
                        const dir = original.clone().normalize(); // Dire√ß√£o para fora
                        // Interpola√ß√£o entre posi√ß√£o original e posi√ß√£o explodida
                        const target = original.clone().add(dir.multiplyScalar(settings.vistaExplodida));
                        child.position.lerp(target, 0.1);
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

// Impede o clique direito (Menu de contexto)
document.addEventListener('contextmenu', event => event.preventDefault());
 
// Impede atalhos comuns de inspe√ß√£o (F12, Ctrl+Shift+I, Ctrl+U)
document.onkeydown = function(e) {
    if(e.keyCode == 123) return false; // F12
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) return false;
}
        animate();
    </script>
</body>
</html>