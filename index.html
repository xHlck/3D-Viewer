<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>VTC 800 - Industrial Viewer</title>
    <style>
        body { margin: 0; background: radial-gradient(circle, #2a2a2a, #000); overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 1.2rem; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading">CARREGANDO SISTEMA...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'; // CORREÃ‡ÃƒO 1: Importar DRACOLoader
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- CENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // --- ILUMINAÃ‡ÃƒO ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- SISTEMA DE ALARME ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 0, 0, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: createGlowTexture(), 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0,
            blending: THREE.AdditiveBlending 
        });
        const alarmSprite = new THREE.Sprite(spriteMaterial);
        alarmSprite.scale.set(1.5, 1.5, 1.5);
        alarmSprite.position.set(0, 3.2, 0); 
        scene.add(alarmSprite);

        const alarmRealLight = new THREE.PointLight(0xff0000, 0, 6);
        alarmRealLight.position.copy(alarmSprite.position);
        scene.add(alarmRealLight);

        // --- CONTROLES ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // --- ESTADO ---
        const settings = {
            rotacao: false,
            flutuar: false,
            vistaExplodida: 0,
            xray: false,
            wireframe: false,
            luzAlarme: false,
            autoZoom: false,
            reset: () => {
                controls.reset();
                settings.rotacao = false;
                settings.xray = false;
                settings.vistaExplodida = 0;
                toggleXRay(false);
                gui.controllers.forEach(c => c.updateDisplay());
            }
        };

        // --- GUI ---
        const gui = new GUI({ title: 'Painel VTC 800' });
        const f1 = gui.addFolder('Movimento');
        f1.add(settings, 'rotacao').name('RotaÃ§Ã£o Auto');
        f1.add(settings, 'flutuar').name('FlutuaÃ§Ã£o');
        f1.add(settings, 'vistaExplodida', 0, 4).name('ExplosÃ£o');

        const f2 = gui.addFolder('DiagnÃ³stico Visual');
        f2.add(settings, 'xray').name('Modo Raio-X').onChange(toggleXRay);
        f2.add(settings, 'wireframe').name('Modo Aramado').onChange(toggleWireframe);
        f2.add(settings, 'luzAlarme').name('ðŸš¨ ALARME GERAL').onChange(toggleAlarm);
        
        const f3 = gui.addFolder('CÃ¢mera');
        f3.add(settings, 'reset').name('Resetar Tudo');

        // --- CARREGAMENTO DO MODELO ---
        let model = null;
        let originalPositions = new Map();

        // CORREÃ‡ÃƒO 2: Instanciar DracoLoader diretamente (sem o prefixo THREE.)
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);

        // AVISO: Substitua 'seu_modelo.glb' pelo nome do arquivo que vocÃª subiu no GitHub
        const modelPath = 'VTC800-v1.glb'; 

        loader.load(modelPath, function (gltf) {
            model = gltf.scene;
            
            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);
            model.position.sub(center);

            scene.add(model);
            document.getElementById('loading').style.display = 'none';

            model.traverse(child => {
                if (child.isMesh) {
                    originalPositions.set(child.uuid, child.position.clone());
                }
            });

        }, (xhr) => {
            console.log((xhr.loaded / xhr.total * 100) + '% carregado');
        }, (e) => {
            console.error("Erro ao carregar o modelo:", e);
            document.getElementById('loading').innerHTML = "ERRO AO CARREGAR MODELO (VERIFIQUE O CAMINHO)";
        });

        // --- FUNÃ‡Ã•ES ---
        function toggleWireframe(value) {
            if (!model) return;
            model.traverse(child => {
                if (child.isMesh && child.material) child.material.wireframe = value;
            });
        }

        function toggleXRay(value) {
            if (!model) return;
            model.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.transparent = value;
                    child.material.opacity = value ? 0.3 : 1.0;
                    child.material.depthWrite = !value;
                }
            });
        }

        let alarmInterval = null;
        function toggleAlarm(value) {
            if (value) {
                let active = false;
                alarmInterval = setInterval(() => {
                    active = !active;
                    alarmSprite.material.opacity = active ? 1 : 0.2;
                    alarmRealLight.intensity = active ? 50 : 0;
                }, 300);
            } else {
                clearInterval(alarmInterval);
                alarmSprite.material.opacity = 0;
                alarmRealLight.intensity = 0;
            }
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            if (model) {
                if (settings.rotacao) model.rotation.y += delta * 0.5;
                if (settings.flutuar) model.position.y = Math.sin(elapsed * 1.5) * 0.1;

                model.traverse(child => {
                    if (child.isMesh && originalPositions.has(child.uuid)) {
                        const original = originalPositions.get(child.uuid);
                        const dir = original.clone().normalize();
                        const target = original.clone().add(dir.multiplyScalar(settings.vistaExplodida));
                        child.position.lerp(target, 0.1);
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

